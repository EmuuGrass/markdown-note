##深入浅出Java垃圾回收机制##

 Stop-the-world会在任何一种GC算法中发生。Stop-the-world意味着 JVM 因为要执行GC而停止了应用程序的执行。当Stop-the-world发生时，除了GC所需的线程以外，所有线程都处于等待状态，直到GC任务完成。GC优化很多时候就是指减少Stop-the-world发生的时间。

###按代的垃圾回收机制

在Java程序中不能显式地分配和注销内存。有些人把相关的对象设置为null或者调用System.gc()来试图显式地清理内存。设置为null至少没什么坏处，但是调用System.gc()会显著地影响系统性能，必须彻底杜绝（还好，我还没有见到NHN的哪个开发者调用这个方法）。

在Java中，开发人员无法直接在程序代码中清理内存，而是由垃圾回收器自动寻找不必要的垃圾对象，并且清理掉他们。垃圾回收器会在下面两种假设（hypotheses）成立的情况下被创建（称之为假设不如改为推测（suppositions）或者前提（preconditions））。

 - 大多数对象会很快变得不可达
 - 只有很少的由老对象（创建时间较长的对象）指向新生对象的引用

这些假设我们称之为 **弱年代假设**（ weak generational hypothesis）。为了强化这一假设，HotSpot虚拟机将其物理上划分为两个–**新生代**（young generation）和**老年代**（old generation）。

**新生代**（Young generation）: 绝大多数最新被创建的对象会被分配到这里，由于大部分对象在创建后会很快变得不可到达，所以很多对象被创建在新生代，然后消失。对象从这个区域消失的过程我们称之为”minor GC“。

**老年代**（Old generation）: 对象没有变得不可达，并且从新生代中存活下来，会被拷贝到这里。其所占用的空间要比新生代多。也正由于其相对较大的空间，发生在老年代上的GC要比新生代少得多。对象从老年代中消失的过程，我们称之为”major GC“（或者”full GC“）

![](http://i.imgur.com/mw2QR1P.png)

上图中的持久代（ permanent generation ）也被称为方法区（method area）。他用来保存类常量以及字符串常量。因此，这个区域不是用来永久的存储那些从老年代存活下来的对象。这个区域也可能发生GC。并且发生在这个区域上的GC事件也会被算为major GC。

有些人可能会问：

**如果老年代的对象需要引用一个新生代的对象，会发生什么呢？**

为了解决这个问题，老年代中存在一个”card table“，他是一个512 byte大小的块。所有老年代的对象指向新生代对象的引用都会被记录在这个表中。当针对新生代执行GC的时候，只需要查询card table来决定是否可以被收集，而不用查询整个老年代。这个card table由一个write barrier来管理。write barrier给GC带来了很大的性能提升，虽然由此可能带来一些开销，但GC的整体时间被显著的减少。

![](http://i.imgur.com/xvukPEz.png)

为了更好地理解GC，我们现在来学习新生代，新生代是用来保存那些第一次被创建的对象，他可以被分为三个空间

 - 一个伊甸园空间（Eden ）
 - 两个幸存者空间（Survivor ）
 - 
一共有三个空间，其中包含两个幸存者空间。每个空间的执行顺序如下：

1.绝大多数刚刚被创建的对象会存放在伊甸园空间。
2.在伊甸园空间执行了第一次GC之后，存活的对象被移动到其中一个幸存者空间。
3.此后，在伊甸园空间执行GC之后，存活的对象会被堆积在同一个幸存者空间。
4.当一个幸存者空间饱和，还在存活的对象会被移动到另一个幸存者空间。之后会清空已经饱和的那个幸存者空间。
在以上的步骤中重复几次依然存活的对象，就会被移动到老年代。
5.如果你仔细观察这些步骤就会发现，其中一个幸存者空间必须保持是空的。如果两个幸存者空间都有数据，或者两个空间都是空的，那一定标志着你的系统出现了某种错误。

通过频繁的minor GC将数据移动到老年代的过程可以用下图来描述：
![](http://i.imgur.com/2vXDKNe.png)

