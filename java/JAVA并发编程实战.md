##JAVA并发编程实战

###加锁机制

1. 内置锁：同步代码块（Synchronized Block）。每个对象都有一个内置锁。
2. 重入：如果某个线程试图获得一个已经由它自己持有的锁，那么这个请求就会成功。比如子类实现了父类的方法并在方法内调用了父类的同个方法，这时如果两个方法都加了锁，这两个方法又是同一个方法，如果不可重入，那么将会产生死锁。

###同步的两个重要方面（Synchronized）

1. 用于实现原子性或确定临界区。
2. 内存可见性。当一个线程修改了对象状态后，其他线程能够看到发生的状态变化。有点类似于事务的隔离级别中的读已提交。

> 加锁机制既可以保证原子性又可以保证可见性。Volatile只能确保可见性。

####只有当满足以下所有条件时，才应该使用volatile变量：

1. 对变量的写入操作不会依赖于变量的当前值，或者只有单个线程更新变量的值。
2. 该变量不会与其他变量一起纳入不变性条件中。
3. 在访问变量时不需要加锁。

**线程封闭**：仅在单线程内访问数据，就不需要同步。

  维持线程封闭性的其中一个方法是使用**ThreadLocal**。ThreadLocal在每个线程中对该变量会创建一个副本，即每个线程内部都会有一个该变量，且在线程内部任何地方都可以使用，线程之间互不影响，这样一来就不存在线程安全问题，也不会严重影响程序执行性能。

    注意：当您在一个类中使用了 static 成员变量的时候，一定要多问问自己，这个 static 成员变量需要考虑“线程安全”吗？（也就是说，多个线程需要独享自己的 static 成员变量吗？）如果需要考虑，那就请用 ThreadLocal 吧！

> 不可变对象一定是线程安全的

**不可变对象：**

1. 对象创建以后其状态就不能更改
2. 对象的所有域都是final类型
3. 对象是正确创建的（在对象创建期间，this引用没有逸出）

